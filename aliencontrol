#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""The aliencontrol ROS node

This ROS node allows controlling the execution of external programs from within
a ROS node. "External" refers to binary files and scripts that are not ROS
nodes, for example bash scripts and system programs. "To control" means starting
and stopping these applications.

In order to start an external process, pass the following commands to
aliencontrol.

Examples:
    # Start an aliencontrol node that launches top inside the current terminal.
    $ rosrun aliencontrol aliencontrol "top"

    # Launch top in a separate terminal.
    $ rosrun aliencontrol aliencontrol "xterm -e top"

These commands spawn a aliencontrol ROS node. The node terminates once you quit
the external application. If you terminate the node, aliencontrol it will
automatically kill the external application before shutting down.
"""

# Import the required system libraries.
import argparse
import os
import rclpy
import subprocess
import signal
import sys


# Start the aliencontrol ROS node.
if __name__ == '__main__':
    # Register the node with the roscore.
    rclpy.init(args=sys.argv)
    # TODO why anonymous in rospy.init_node('aliencontrol', anonymous=True) ?
    node = rclpy.create_node("aliencontrol")
    context = rclpy.utilities.get_default_context()

    # Extract the command to execute from the input arguments. Accept both a ROS
    # private parameter (like in "rosrun aliencontrol aliencontrol _cmd:=top")
    # or an anonymous parameter (like in 
    # "rosrun aliencontrol aliencontrol top").
    cmd = ''
    if rospy.has_param('~cmd'):
        # Read the parameter from the ROS parameter server.
        cmd = rospy.get_param('~cmd')
    else:
        # Read the anonymous parameter.
        args = rospy.myargv(argv=sys.argv)

        # Delete the first input argument, which is always the path of this
        # script.
        del(args[0])

        # Extract the command.
        parser = argparse.ArgumentParser(
            description='Control external program from within a ROS node.')
        parser.add_argument('cmd', help='external command to execute')
        cmd = parser.parse_args(args).cmd

    # Start the external application as a process group. In this way, we make
    # sure to control not only the external process, but all of its
    # subprocesses.
    # rospy.loginfo('Executing command \"%s\" ...', cmd)
    node.get_logger().info('Executing command \"%s\" ...', cmd)
    alien = subprocess.Popen(args=cmd, shell=True, preexec_fn=os.setsid)

    # Define the shutdown handler.
    def shutdown():
        """Shutdown handler
        
        Shuts down the external application using a sequence of signals. 
        """

        node.get_logger().info('Shutting down aliencontrol ...')

        # Shut down the external application, if it is still running.
        try:
            if alien.poll() == None:
                # Retrieve the ID of the process group that represents the
                # external application.
                pgid = os.getpgid(alien.pid)

                # Ask the process to gracefully shut down using SIGINT.
                node.get_logger().info(
                    'Sending SIGINT to external process (PGID=%i, CMD=%s) ...',
                    pgid, cmd)
                os.killpg(pgid, signal.SIGINT)

                # Give the process some time to shut down.
                wait_duration = rclpy.Duration(seconds=5)
                node.get_logger().info(
                    'Waiting for %i s until escalating to SIGTERM ...',
                    wait_duration.secs)
                wait_time_end = node.get_clock().now() + wait_duration
                rate = rclpy.timer.Rate(100)
                while wait_time_end > node.get_clock().now():
                    rate.sleep()
                    if alien.poll() != None:
                        node.get_logger().info('External process is shut down.')
                        return

                # Ask the process to shut down using SIGTERM.
                node.get_logger().warn(
                    'Sending SIGTERM to external process (PGID=%i, CMD=%s) ...',
                    pgid, cmd)
                os.killpg(pgid, signal.SIGTERM)

                # Give the process some more time to shut down.
                node.get_logger().info(
                    'Waiting for %i s until killing the process ...',
                    wait_duration.secs)
                wait_time_end = node.get_clock().now() + wait_duration
                while wait_time_end > node.get_clock().now():
                    rate.sleep()
                    if alien.poll() != None:
                        node.get_logger().info('External process is shut down.')
                        return

                # If the process is still running, kill it.
                node.get_logger().warn(
                    'Sending SIGKILL to external process (PGID=%i, CMD=%s) ...',
                    pgid, cmd)
                os.killpg(pgid, signal.SIGKILL)
        except Exception as e:
            node.get_logger().error(e)
            raise

    # Register the shutdown handler.
    context.on_shutdown(shutdown)

    # Poll the external process to see if it is still active. If not, exit.
    rate = rclpy.timer.Rate(10)
    while (context.ok() and (alien.poll() == None)):
        rate.sleep()

    # TODO have to call rclpy.shutdown()?
    rclpy.shutdown()
